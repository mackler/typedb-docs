= Connecting to TypeDB
:keywords: typedb, studio, console, connect, connection, session, transaction, database
:page-aliases: typedb::development/connect.adoc
:pageTitle: Connecting
:summary: Brief description of connection to TypeDB.
:tabs-sync-option:

[#_clients]
== Clients

A TypeDB Client is any software that can connect to a TypeDB.

TypeDB server accepts remote connections from any TypeDB Clients:
xref:typedb::connecting/studio.adoc[],
xref:typedb::connecting/console.adoc[], and
xref:clients:ROOT:overview.adoc[TypeDB Drivers].

Once connected, TypeDB Clients can manage <<_databases,databases>>, <<_sessions,sessions>>, and
<<_transactions, transactions>>.

[tabs]
====
TypeDB Console::
+
--
[,bash]
----
typedb console --server=127.0.0.1:1729
----
--

Java::
+
--
[,java]
----
TypeDBDriver driver = TypeDB.coreDriver("127.0.0.1:1729");
----
--

Python::
+
--
[,python]
----
driver = TypeDB.core_driver("127.0.0.1:1729")
----
--

Node.js::
+
--
[,js]
----
driver = TypeDB.coreDriver("127.0.0.1:1729");
----
--
====

[NOTE]
====
To connect to TypeDB Cloud or TypeDB Enterprise use `enterpriseDriver`/`enterprise_driver` instead of
`coreDriver`/`core_driver`.
====

[#_protocol_version]
=== Protocol version control

There is a server-side check for the TypeDB protocol encoding version.
This is to prevent any potential errors from using incompatible versions of TypeDB Client and TypeDB.

See the compatibility tables for protocol encoding versions of:
xref:typedb::connecting/studio.adoc#_version_compatibility[TypeDB Studio],
xref:typedb::connecting/console.adoc#_version_compatibility[TypeDB Console], and TypeDB Drivers:
xref:clients::rust-driver/overview.adoc#_version_compatibility[Rust],
xref:clients::python-driver/overview.adoc#_version_compatibility[Python],
xref:clients::java-driver/overview.adoc#_version_compatibility[Java],
xref:clients::nodejs-driver/overview.adoc#_version_compatibility[Node.js].

For backward compatibility protocol version control allows TypeDB Clients versions prior to `2.18.0` (i.e., with
protocol encoding version N/A, or < 1) to connect with a TypeDB server with protocol encoding version 1.

If we try to connect with a newer client to an older server (prior to version `2.18.0`), we should get an error
due to the older server lacking the API to check the protocol version.

[#_databases]
== Databases

TypeDB instances can contain multiple databases. A database consists of a xref:development/schema.adoc[schema] and
xref:development/write.adoc[data]. It is both separate and independent of any other database: two databases can't influence
each other. However, TypeDB Clients can connect to multiple databases simultaneously.

[NOTE]
====
TypeDB is optimized for a small number of databases. It's recommended to start with a single database and add more if
necessary, e.g., to support more applications. The **best practice** is to keep the number of databases **under 10**.
====

[tabs]
====
TypeDB Console::
+
--
[,bash]
----
# create database
database create test-db
# get database schema
database schema test-db
# list all databases
database list
# delete database
database delete test-db
----
--

Java::
+
--
[,java]
----
// create database
driver.databases().create("test-db");
// get database schema
driver.databases().get("test-db").schema();
// get all databases
driver.databases().all();
// check if database exists
driver.databases().contains("test-db");
// delete database
driver.databases().get("test-db").delete();
----
--

Python::
+
--
[,python]
----
# create database
driver.databases().create("test-db")
# get database schema
driver.databases().get("test-db").schema()
# get all databases
driver.databases().all()
# check if database exists
driver.databases().contains("test-db")
# delete database
driver.databases().get("test-db").delete()
----
--

Node.js::
+
--
[,js]
----
// create database
await driver.databases().create("test-db");
// get database schema
await driver.databases().get("test-db").schema();
// get all databases
await driver.databases().all();
// check if database exists
await driver.databases().contains("test-db");
// delete database
await (await driver.databases().get("test-db")).delete();
----
--
====

[#_sessions]
== Sessions

A session is like a tunnel connection to a database in a TypeDB server. An open session lets us open transactions
in it.

image::clients::concurrency-model.png[Session-transaction-query, role=framed, width = 75%, link=self]

Any TypeDB Client automatically exchanges internal signals with TypeDB server to keep a session alive when it's open.
If server doesn't receive this signal for a period of time bigger than the timeout (by default, 30 secs) it
forcibly closes the session due to inactivity.

There are two types of sessions: `schema` and `data`.

[WARNING]
====
Only one *Schema* session can be open at any time. And any open *Schema* session blocks all attempts to open a
*Data Write* transaction. For more information on these limits see the <<_schema_integrity>> section.
====

[cols="^,^,^,^,^",options="header"]
|===
| Session type | Read data | Write data | Read schema | Write schema

| DATA
| Yes
| Yes
| Yes
| *No*

| SCHEMA
| Yes
| *No*
| Yes
| Yes
|===

Write transactions are strict to session types.
TypeDB Clients can write data only in DATA sessions and can write schema only in SCHEMA sessions (see the table above).

[NOTE]
====
If a client needs to read both schema and data from a database, it can be done in any session type (usually used when
a data query needs information on types).
But it is NOT possible to modify a schema and data in the same session.
====

[tabs]
====
TypeDB Console::
+
--
[,bash]
----
transaction iam data read
----
--

Java::
+
--
[,java]
----
TypeDBSession session = driver.session("iam", TypeDBSession.Type.DATA);
----
--

Python::
+
--
[,python]
----
session = driver.session("iam", SessionType.DATA)
----
--

Node.js::
+
--
[,js]
----
session = await driver.session("iam", SessionType.DATA);
----
--
====

Sessions must be explicitly opened and closed by TypeDB Clients.

For more information on how to do it with different TypeDB Clients, see the documentation:

* xref:connecting/studio.adoc#_transaction_control[TypeDB Studio]
* xref:connecting/console.adoc#_database_management_commands[TypeDB Console]
* TypeDB Drivers:
** xref:clients:ROOT:rust-driver/api-reference.adoc#_session_header[Rust],
** xref:clients:ROOT:python-driver/api-reference.adoc#_session_header[Python],
** xref:clients:ROOT:java-driver/api-reference.adoc#_session_header[Java],
** xref:clients:ROOT:nodejs-driver/api-reference.adoc#_session_header[Node.js].

[IMPORTANT]
====
It is recommended to avoid long-running sessions because of possible network failures.
====

A good principle to follow is for logically coherent transactions to be grouped into a session.

[#_transactions]
== Transactions

All queries to a TypeDB database are performed through transactions. TypeDB transactions provide full
<<_acid_guarantees,ACID guarantees>> up to <<_isolation,snapshot isolation>>.

There are two types of transactions: `read` and `write`.

Transactions must be explicitly opened and closed by a TypeDB Client.
A transaction can be opened only inside an opened session.

[tabs]
====
TypeDB Console::
+
--
[,bash]
----
# start transaction
transaction iam data write
insert $x isa person;
$x has full-name "Kevin";
$x has email "Kevin@vaticle.com";
# commit changes
commit
----
--

Java::
+
--
[,java]
----
// start transaction
TypeDBTransaction transaction = session.transaction(TypeDBTransaction.Type.WRITE);
transaction.query().insert(insertQuery1);
transaction.query().insert(insertQuery2);
transaction.query().insert(insertQueryN);
// commit changes
transaction.commit();
----
--

Python::
+
--
[,python]
----
# start transaction
transaction = session.transaction(TransactionType.WRITE)
transaction.query().insert(insert_query1)
transaction.query().insert(insert_query2)
transaction.query().insert(insert_queryN)
# commit changes
transaction.commit()
----
--

Node.js::
+
--
[,js]
----
// start transaction
const transaction = await session.transaction(TransactionType.WRITE);
transaction.query().insert(InsertQuery1);
transaction.query().insert(InsertQuery2);
transaction.query().insert(InsertQueryN);
// commit changes
await transaction.commit();
----
--
====

TypeDB Studio manages sessions automatically and lets you control transactions through its GUI.

For more information on how to do it with different Clients, see the documentation:

* xref:connecting/studio.adoc#_transaction_control[TypeDB Studio]
* xref:connecting/console.adoc#_transaction_querying_commands[TypeDB Console]
* TypeDB Drivers:
** xref:clients:ROOT:rust-driver/api-reference.adoc#_transaction_header[Rust],
** xref:clients:ROOT:python-driver/api-reference.adoc#_transaction_header[Python],
** xref:clients:ROOT:java-driver/api-reference.adoc#_transaction_header[Java],
** xref:clients:ROOT:nodejs-driver/api-reference.adoc#_transaction_header[Node.js].

TypeDB transactions use snapshot isolation and optimistic concurrency control to support concurrent, lock-free
read/write transactions. For more information, see the <<_acid_guarantees>> section below.

=== Transaction time limit

TypeDB transactions have a duration limit.
By default, it's *5 minutes*.
The default value can be changed with Client options.

The time limit is intended to encourage short-lived transactions, prevent memory leaks
caused by transactions that will not be completed and terminate unresponsive transactions.

=== Best practices

* Avoid long-running transactions which can result in conflicts and resource contention.
* Transactions should group logically coherent queries.

For more advice and *best practices*, visit the xref:development/best.adoc[Best practices] page.

[#_acid_guarantees]
== ACID guarantees

All TypeDB transactions have ACID guarantees.

* <<_atomicity>>
* <<_consistency>>
* <<_isolation>>
* <<_durability>>

Schema operations have additional concurrency restrictions to guarantee schema integrity.
See the <<_schema_integrity>> section.

[#_atomicity]
=== Atomicity

TypeDB transactions are all or nothing. If a commit succeeds, all of its changes are persisted. If it fails, all of its
changes will be rolled back.

[#_consistency]
=== Consistency

TypeDB validates all changes to data and schemas. If changes to a database violate schema or data constraints, the
transaction will fail and be rolled back.

[#_isolation]
=== Isolation

TypeDB transactions use snapshot isolation and optimistic concurrency control to support simultaneous, lock-free
read/write transactions. Thus, a transaction operates on its snapshot of the data, independent of any other. All
of its changes are hidden from other transactions. However, they will become visible immediately after a successful
commit.

If two transactions attempt to modify the same data, one will succeed on commit while the other will fail. However,
one transaction can read data while another is writing it.

[#_durability]
=== Durability

TypeDB writes transactions to a write-ahead log upon commit, ensuring they can be recovered if an unexpected failure,
e.g., power outage, occurs before the data is modified.

[NOTE]
====
TypeDB durability guarantees do not apply when storage devices become corrupt or damaged.
====

Successful write transactions are written to the write-ahead log before returning a response to the client. If a
transaction is not successful, all changes are rolled back.

For TypeDB Enterprise and TypeDB Cloud installations, transaction acknowledgment is sent to the client after a majority
of replicas replicated the transaction results. See xref:managing/ha.adoc#_replication[Replication] for details.

[#_schema_integrity]
=== Schema integrity enforcement

* Only one *Schema* session can be opened.

* Only one *Write* transaction in a *Schema* session can be opened.

* Opening a *Schema* session prevents any *Data Write* transactions.

* Any *Write* transaction opened in a *Data* session prevents us from opening a *Schema* session.

[NOTE]
====
If anything prevents us from opening a session, TypeDB will wait for a timeout of about *10 seconds* and, if the problem
persists, throw an error:

----
[SSN03] Invalid Session Operation: Could not acquire lock for schema session. Another schema session may have been left open.
----
====

Hence, we can always:

* open *Data* session,
* open a *Read* transaction in an existing session of any type.

== Learn more

Learn how to develop an application with TypeDB:

* xref:typedb::development/schema.adoc[]
* xref:typedb::development/write.adoc[]
* xref:typedb::development/read.adoc[]
