= Introduction
:keywords: typedb, database, documentation, introduction, overview
:longTailKeywords: typedb introduction, typedb overview, learn typedb, learn typeql, typedb schema, typedb data model
:pageTitle: TypeDB introduction
:summary: An intriduction for TypeDB's documentation

// tag::typedb-poly-definition[]
TypeDB is a polymorphic database with a conceptual data model, a strong subtyping system, a symbolic reasoning engine,
and a beautiful and elegant type-theoretic language: TypeQL.
// end::typedb-poly-definition[]

== Short summary

TypeDB is a transactional DBMS with xref:basics/acid-guarantees.adoc[] that has the following main features:

* TypeDB uses an enhanced Entity-Relationship model, extended with Attributes as first-class citizens;
* TypeDB has its own special static type system, supporting user-defined types with subtyping and inheritance,
  like OOP languages;
* TypeDB can use rule-based logic embedded into a database schema to infer new data from patterns found in existing data;
* TypeDB uses its own declarative query language -- xref:typeql::overview.adoc[TypeQL].

The core of any TypeDB database is its schema.
A schema is a conceptual (logical) data model rather than a physical one and consists of types and rules.

Using xref:typeql::overview.adoc[TypeQL], we define a schema to model business domains true to life.

We build data queries using declarative and composable patterns, written in TypeQL, and types, defined in schema.

== Comparison with other databases
//#todo add direct comparison materials links

TypeDB looks beyond relational and NoSQL databases by harnessing subtyping to trivially write polymorphic queries and
introducing a strong type system, extending it with inference and pattern matching for simple yet powerful querying.

TypeDB uses the Enhanced Entity-Relationship model with a declarative schema and static type checking.
This allows the natural implementation of a type hierarchy, multivalued attributes, and n-ary and nested relations.
Leverage OOP concepts like abstraction, inheritance, and polymorphism without warping the conceptual model.
Normalization, null values, and reification are things of the past.

Some examples of what TypeDB is not:

* TypeDB is not an SQL database, but it uses an enhanced Entity-Relationship model that is extended by attributes as
  first-class citizens;
* TypeDB is not a graph database, but it utilizes the power of hypergraphs without asking developers to understand the
  implementation details;
* TypeDB is not an object-oriented database, but it uses types with subtyping and inheritance to model data.

//#todo Consider adding some of the content from the website

For more information on comparison with other types of databases, see the
https://typedb.com/introduction[Introduction to TypeDB] page of our website.

== Top features

=== Strong type system

TypeDB brings the benefits of strong typing in modern programming languages to the database, allowing developers
to use abstraction, inheritance, and polymorphism when modeling and querying data – and finally removing the mismatch
between logical and physical data models.

TypeDB has a strict hierarchy of types, expandable by adding new types. Every new type should be a subtype of exactly one
supertype -- either a built-in type or another user-defined type.

Any TypeDB database has the following built-in types:

* `entity` -- A root type for all entities. An entity represents a self-sufficient object.
* `relation` -- A root type for all relations. A relation represents an n-ary relationship between other types.
* `attribute` -- A root type for all attributes. An attribute represents a property with a value.

An accurate type hierarchy can add context and constraints to data using strong typing and inheritance.

.Example of a type hierarchy in a schema

[,typeql]
----
define

user sub entity,
    owns username,
    plays group-membership:member;

person sub user,
    owns full-name,
    owns email,
    owns password-hash;

bot sub user,
    owns security-token;

user-group sub entity,
    owns name,
    plays group-membership:group;

group-membership sub relation,
    owns date-added;
    relates group,
    relates member;

username sub attribute, value string;
full-name sub attribute, value string;
name sub attribute, value string;
email sub attribute, value string;
password-hash sub attribute, value string;
security-token sub attribute, value string;
date-added sub attribute, value datetime;
----

See below a TypeDB Studio visualization of that schema:

[caption=""]
.Type hierarchy example schema graph visualization
image::intro-hierarchy-schema.png[Type hierarchy]

For more information on how strong our type system is, see the xref:typeql::fundamentals.adoc#_types[Types] section on
xref:typeql::fundamentals.adoc[Fundamentals page] in xref:typeql::overview.adoc[TypeQL documentation].

=== Rule inference

Rules represent logic embedded in a schema.
Inference is a logical deduction based on a set of rules defined in a schema.

When READ type transactions are running with the _inference_ option enabled,
TypeDB can deduce new (virtual) attribute ownerships and relations if they influence the query results.

Virtual (inferred) data is not persisted and will be lost when the transaction is closed.

==== Examples

===== Inferring new data
//#todo Consider less levels of headings

.Everyone is a dude rule example
[,typeql]
----
define

rule everyone-is-a-dude:
    when {
        $p isa person;
    } then {
        $p has full-name "Dude";
    };
----

The above example will add a `full-name` attribute with value `Dude` to every existing person.

Let’s add to the above schema an ability for user-groups to be members of other user-groups.

===== Transitive relations

.Add an ability for a group to be a member of a group
[,typeql]
----
define

user-group plays group-membership:member;
----

Now, we can add a new rule to enable transitive group membership. We can include Group A in Group B,
so that every member of Group A will become a member of Group B through the transitivity of membership, as follows:

`person` -> Group A -> Group B.

.Transitive group membership rule example
[,typeql]
----
define

rule transitive-group-membership:
   when {
      (group: $g1, member: $g2) isa group-membership;
      (group: $g2, member: $p) isa group-membership;
   } then {
      (group: $g1, member: $p) isa group-membership;
   };
----

The above rule works for any number of groups.

For example, if we insert data of group-membership according to the following:

`person` -> Group A -> Group B -> Group C -> Group D -> Group E

where `->` -- means a `group-membership` relation with an entity on the left of the -> playing the role of `member`
and the entity on the right playing the role of `group`. Then the transitivity, implemented by
the `transitive-group-memmbership` rule, will make `person` into a member of all groups from A to E.

For more information on rule inference, see the xref:typeql::schema/define-rules.adoc[] page
in xref:typeql::overview.adoc[TypeQL documentation].

=== Truly declarative and composable data queries

TypeQL is designed specifically for expressing what data looks like, not how to get it.
There are no joins, no unions, and no need for ordered query logic.

Data queries are based on powerful yet simple patterns, using types defined in a schema of a database.
Those patterns are easily readable and composable.
We can add new statements to any place in a pattern, and we can even combine multiple patterns,
to retrieve all matching data in just one query.

==== Examples

The following Insert query creates two instances of the `person` type, and two groups and assigns a membership in one
of the groups for one of the users:

.Insert query example
[,typeql]
----
insert
$p1 isa person,
    has full-name "Bob",
    has name "bob90",
    has email "bob@vaticle.com";

$p2 isa person,
    has full-name "Alex",
    has name "al-capucino";

$g1 isa user-group,
    has name "admins";

$g2 isa user-group,
    has name "users";

$m (member: $p1, group: $g1) isa group-membership;
----

The following query retrieves data of all instances of `user` type (which is a supertype for the `person` type) that
have ownership over any attribute.
It returns all matched instances of `user` type or its subtypes and the attributes they own.

.Get query
[,typeql]
----
match
$u isa user, has $a;
----

The following query executes `match` clause first and then `insert` clause using matched data.
The `match` clause matches all instances of `person` type and all instances of `user-group` type, owning an attribute of
type `name` and value `users` such as there is no `group-membership` relation between them.
Then the `insert` clause inserts a `group-membership` relation between all matched instances of `person`
and all matched instances of `group`:

.Insert query with a match clause
[,typeql]
----
match
$p isa person;
$g isa user-group,
    has name "users";
not { ($p, $g) isa group-membership; };
insert
(member:$p, group:$g) isa group-membership;
----

== TypeDB editions

There are three editions of TypeDB:

* <<_typedb_cloud,TypeDB Cloud>>
* <<_typedb_enterprise,TypeDB Enterprise>>
* <<_typedb_core,TypeDB Core>>

For more information on the availability of features in all editions,
see the https://typedb.com/deploy[Deploy] page of our website.

[#_typedb_cloud]
=== TypeDB Cloud

TypeDB Cloud is our DBaaS solution.

TypeDB Cloud is built on Kubernetes and makes it easy to run and manage TypeDB deployments across multiple teams
and projects in AWS, Azure, and GCP.

//Your TypeDB databases run in clusters managed by us and deployed in cloud powered by https://aws.amazon.com/[AWS] or https://cloud.google.com/[GCP].

[#_typedb_enterprise]
=== TypeDB Enterprise

TypeDB Enterprise extends TypeDB Core with advanced security and high-availability features for running in production,
including active-active clustering and authentication with roles.

Self-hosted, self-managed on-premise TypeDB clusters with our technical support.

[#_typedb_core]
=== TypeDB Core

TypeDB Core is 100% open-source software with an
https://github.com/vaticle/typedb/blob/development/LICENSE[AGPL-3.0 license],
provides developers with everything they need to get started, and is available via a Docker container as well as
Windows, Linux, and macOS builds.

== Learn more

. Install TypeDB locally with the xref:install-and-run.adoc[Installation guide] or deploy it in the
  https://cloud.typedb.com/[TypeDB Cloud].
. Create a database and try some queries with the xref:home/quickstart-guide.adoc[Quickstart guide].
. Learn only essentials about TypeDB with the xref:basics/basics.adoc[] page.
. Learn more about connecting to a database, querying, and troubleshooting in our *Developing with TypeDB* subsection.
. Prepare a production environment with the *Managing TypeDB* subsection.
