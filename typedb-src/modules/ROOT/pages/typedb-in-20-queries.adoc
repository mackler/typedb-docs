= TypeDB in 20 queries
//:toc: macro
//:toclevels: 5
//:toc-title: Top query examples:
:example-caption!:

To showcase the capabilities of TypeDB and its query language TypeQL,
see below a short list of 20 queries designed to give a brief idea of what can be done and how easy it is.

[NOTE]
====
Use our xref:typedb::quickstart-guide.adoc[Quickstart guide]
to find out how to create a new database and send a query.
====

[#_schema]
== #{counter:query}: Defining schema

TypeDB uses Polymorphic Entity-Relation-Attribute (or PERA) Model for its schemas and data.

Entities, relations, and attributes are all first-class citizens in a data model allowing for
expressive modeling without normalization or reification.
There are three root types: `entity`, `relation`, and `attribute`;
and they can be subtyped to create user-defined types.

Consider the following schema diagram:
//, with attributes represented as blue ellipses, entities as pink rectangles, and relations as yellow diamonds:
image:typedb-in-20-queries/era-schema.png[TypeDB Studio GUI, width = 40%, link=self]
//#todo Optimize the image
//Squish vertically by placing relation inline with entities???

Let's see how to define the schema in TypeQL with the PERA model in mind:

[#_pera_schema]
.Schema example
[,typeql]
----
define

id sub attribute, abstract, value string;
name sub id;
username sub id;
email sub id;
path sub id;
size-kb sub attribute, value long;
updated sub attribute, value datetime;

person sub entity,
    owns name;
user sub person,
    owns email @unique,
    owns username @key,
    plays permission:subject;
file sub entity,
    owns path @key,
    owns size-kb,
    plays permission:object;

permission sub relation,
    owns updated,
    relates subject,
    relates object;
----

The above query xref:typeql::schema/define-types.adoc[defines]
seven attribute types, three entity types, and a relation type.

To try extending the schema, see the <<_extend_schema>> section.

[#_data]
== #{counter:query}: Inserting data

_Run this query after <<_schema,query #1>>._

All data stored in a database must be instantiated from types defined in a schema of a database.

Let's insert two users, two files, and set permissions:

[#_sample_data1]
.Insert query example
[,typeql]
----
insert
    $p isa person,
        has name "Charlie";
    $u1 isa user,
        has name "Bob",
        has username "bob_93",
        has email "bob@vaticle.com";
    $u2 isa user,
        has username "al-capucino";
    $f1 isa file,
        has path "README.md";
    $f2 isa file,
        has path "docs/quickstart-guide.adoc",
        has size-kb 345;
    $p1(subject:$u1, object:$f1) isa permission, has updated 2023-06-30T12:04:36;
    $p2(subject:$u2, object:$f2) isa permission;
----

The above query xref:typeql::data/insert.adoc[inserts] one instance of the `person` type,
two `user` entities,
two `file` entities,
two relations of the `permission` type,
and some attributes owned by the entities and one of the relations.

To try matching existing data before inserting, check the <<_match_insert>> section.

[#_get]
== #{counter:query}: Retrieving data

_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

Patterns for data queries are based on types defined in a schema.
All queries are validated both syntactically and semantically.
To get usernames of all users that have access to the file with path `README.md`:

.Get query example
[,typeql]
----
match
    $u isa user,
        has username $un;
    $f isa file,
        has path "README.md";
     $p(subject:$u, object:$f) isa permission;
get $un;
----

The above xref:typeql::data/get.adoc[Get] query matches the `file` entity by the `path` attribute it has ownership of.
Then it finds all users (and their usernames) that participate in a relation of a `permission` type with the file.
The result is filtered to return only the `$un`, which is the `username`.

[#_extend_schema]
== #{counter:query}: Extending schema

_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

A schema of a TypeDB database can be extended at any time without the need to rewrite existing queries.
The easiest way to extend the schema is to add a new type, add an ownership of an attribute type, add a role, or
add an ability to play a new role with a xref:typeql::schema/define-types.adoc[Define] query.

Let's add a new subtype and a new role to our schema:

[#_schema_extension]
.Schema extensions example
[,typeql]
----
define

action sub entity,
    owns name,
    plays permission:permitted-action;

admin sub user;

permission relates permitted-action;
----

The above Define query extends the existing schema
by adding two new entity types and a role to an existing relation type.

[#_match_insert]
== #{counter:query}: Matching and then inserting data

_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

Now let's do a match insert by adding a new file and a relevant permission for an existing user:

.Match insert example
[,typeql]
----
match
    $u isa user;
    $f isa file,
        has path "README.md";
    not { ($u, $f) isa permission; };
insert
    ($u, $f) isa permission;
----

The above query matches the file with path `README.md` and all users, that are not in a `permission` relation.
Then it inserts such a relation for every matched `user` and `file`.

The xref:typeql::data/insert.adoc[Insert] query type is the only one that can be used without a `match` clause.
See <<_data,example>>.

== #{counter:query}: Deleting data

_Run this query after <<_schema,query #1>>, <<_data,query #2>>, and  <<_match_insert,query>> <<_match_insert>>._

Deleting data requires matching the data to delete first:

.Delete permissions
[,typeql]
----
match
    $u isa user,
        has username "al-capucino";
    $p(subject:$u) isa permission;
delete
    $p isa permission;
----

The above query will delete all permission relations for the user with username `al-capucino`.

[#_declarative]
== #{counter:query}: Fully declarative query language
_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

TypeQL statements are fully declarative and are combined with a conjunction (logical `AND`)
which makes patterns fully composable.
Every statement is a constraint to be satisfied by the query engine.
You declare constraints for the results and query engine will deal with the implementation,
including planning and optimizing execution.

You can use variables in data queries.
Every matched result is a solution for the `match` clause pattern:
it includes a single concept (a type or an instance of a type) for every variable.

For a xref:typeql::data/get.adoc[Get] query we use a `match` clause to declare a pattern for the data we are looking for
and an optional `get` clause to filter the results.

.Declarative query and composable patterns
[,typeql]
----
match
    $p isa person;
    $p has name $p-name;
    $p-name == "Bob";
    $p has $x;
    not {$x isa name;};
get $x;
----

This query matches only person type entities that own the attribute with type `name` and value `Bob`
and returns all their owned attributes, excluding the name `Bob`.
For the data from <<_data,query #2>> it should return username `bob_93` and email `bob@vaticle.com`.

For the `match` clause pattern we included five simple statements.
All five of them must be met for the matching.

Take notice, that while the query uses the `person` type in its pattern, the matched entity is of the `user` type.
This is due to the fact, that we used `isa` keyword, that takes into account all subtypes of the `person` type,
including the `user` type.
Try the same query with the `isa!` keyword instead.
It is used for an exact type, without subtyping.

== #{counter:query}: Polymorphic queries
_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

You can use polymorphism with queries by not binding a variable to any type or even to a supertype.
That makes it possible for the variable to return different types as matches.
Querying for a supertype can return all results for its subtypes and querying without binding can return any type that matches pattern.

Let's try one of the most generic patterns in TypeQL:

.Polymorphic query example
[,typeql]
----
match $x isa! $type;
----

[discrete]
=== Parametric polymorphjsim

//When we don't bound a variable to a specific type, so it can be solved as multiple different ones.

The above query returns pairs of `$x` and `$type` concepts,
where `$x` should be an instance of data and `$type` should be its type.
Effectively it will return all data from a database
(as `$x`) and all types of the data.
The number of results should be around 16: that's how many instances the database should have after
<<_schema,query #1>> and <<_data,query #2>>.

[discrete]
=== Inheritance Polymorphism

//When we can solve for type and its subtypes

If we switch `isa!` to the `isa` keyword,
we can still get all the data and its types, but also subtypes.
So, there will be results with the same instances (`$x`), but different types (`$type`).
This should increase the number of results to about 57.

== #{counter:query}: Abstract types
_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

xref:typeql::fundamentals.adoc#_abstract_types[Abstract types] can't be instantiated
(no data can be inserted for the abstract type), but can be subtyped.

In schema from <<_schema,query #1>> we defined `id` as an abstract type to subtype it with many different attributes,
that have the same value type and can be called an id.

Now we can do the following query:

.Abstract type example
[,typeql]
----
match $x has id $id;
----

The above query can't retrieve any instances of `id` type because it is an abstract type.
Instead, it returns instances of all its subtypes, see the visualization below.

image::typedb-in-20-queries/abstract.png[Abstract type, width = 50%, link=self]

//Interface polymorphism
//When we seek for anything, that owns or plays

== #{counter:query}: Inheritance
_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

xref:typeql::fundamentals.adoc#_inheritance[Inheritance] lets subtypes use roles and attributes,
defined for their supertype (direct or nested).

Like in the following example:

.Inherited attributes example
[,typeql]
----
match
    $u isa user,
        has name "Bob";
----

We match a user with name `Bob`.
The `user` type inherits the ability to own  the `name` attribute type from its supertype -- the `person` type.
See the schema from the <<_schema,query #1>>.

== #{counter:query}: Overriding inheritance
_Run this query after <<_schema,query #1>>._

You can override an inherited ownership or a role with a new name.
//#todo Add explanation as to why it might be needed
Override uses the keyword `as` with the new type preceding the keyword, and old (inherited) type following the keyword.
The new type should be defined in the schema as a subtype of the overriden (inherited) type.

.Schema
[,typeql]
----
define

user owns full-name as name;

user-permission sub permission,
    relates user as subject;
----

In the above example, we override the inherited `name` attribute type with the `full-name` attribute type,
We also subtype `permission` relation type with the `user-permission`, which overrides the inherited `subject` role
with the `user` role. The `object` role is inherited without overriding in this case.

== #{counter:query}: Relations
_Run this query after <<_schema,query #1>>, <<_data,query #2>>, and <<_extend_schema,query #4>>._
//n-ary
//nested
//variadic (1 role, many role players?)

Relations in TypeDB work elegantly and naturally, without the need for joins,
tables, foreign keys, or any other tricks needed to "just make it work".

A database schema defines relation types and their roles, as well as types that can play a role.
Creating a relation is just instantiating a relation type with the exact role players that you want.

We can create an n-ary relation with just one role, for example,
a `friendship` relation with three role players for the role `friend`.

In <<_extend_schema>> section we extended the schema by adding a third role to the `permission` relation.
Now let's add a role player for this role for a relation, that was inserted before the extension of the schema:

.Relation example
[,typeql]
----
match
    $u isa user,
        has name "Bob";
    $f isa file,
        has path "README.md";
    $p($u, $f) isa permission;
insert
    $a isa action, has name "edit";
    $p(permitted-action:$a);
----

The above query adds `action` entity with name `edit` to the `permission` for the user with name `Bob`
and the file with the path `README.md`.
See the visualization of the result below.

image::typedb-in-20-queries/relation.png[Relation, width = 50%, link=self]

== #{counter:query}: Globally unique immutable attributes
_Run this query after <<_schema,query #1>>, <<_data,query #2>>, and <<_data,query #4>>._

Always optimal storage space and memory requirements as data is naturally deduplicated.

Only attributes have values and all attributes are immutable.
We can't change the value of an attribute,
but we can delete ownership of one attribute and insert ownership of another.

An attribute has a unique value among all instances of the same type.
Hence, there can be no other attribute of the same type with the same value.

.Insert data
[,typeql]
----
match
    $p isa person, has name "Charlie";

insert
    $p has name "Bob";
    $b isa person, has name "Bob", has name "Another Bob";
    $a isa action, has name "Bob";
----

The above query matches the person with name `Charlie`,
and then inserts ownership of the name `Bob` to the person.
The same query also inserts new person with name `Bob` and another name `Another Bob`.
It also creates an action with the name `Bob`.

The trick is,
there is only one attribute of the type `name` and value `Bob`
and all owners from the query above have ownership of this attribute.
As well as the original `Bob` inserted in the <<_data,query #2>>.
The resulted data should look like the image below.

image::typedb-in-20-queries/attribute.png[Relation, width = 50%, link=self]

[#_counterquery_attribute_annotations]
== #{counter:query}: Attribute annotations
_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

When defining an ownership of an attribute type, we can add one of possible annotations: `@key` or `@unique`.
These annotation constraints are limiting what can be inserted into a database.

The `@unique` annotation makes the ownership constrained by uniqueness.
Among all instances of the owner type only one can own any specific attribute of the attribute type
marked with `@unique` annotation.

The `@key` annotation makes the owned attribute a key for the owner type.
That applies the uniqueness constraint and, in addition, imposes a cardinality of exactly one --
all instances of the owner type must have exactly one (no less and no more) instance of the owned attribute.

Consider the schema from the <<_data,query #2>>.

In the schema we xref:typeql::schema/define-types.adoc[defined]
the `username` type to be a key for the `user` type,
and the `email` to be unique, when owned by the `user` type.

Now let's see what will happen, if we'll try to violate these annotations by using the following Insert query:

.Insert data
[,typeql]
----
insert
    $u isa user;
    $u isa user,
        has username "Bob";
    $u isa user,
        has username "Totally-not-Bob",
        has email "bob@vaticle.com";
----

The above query fails as it violates the following annotation constraints:

* the first inserted `user` doesn't have a `username`, which violates the `@key` constraint from the schema;
* the second `user` has `username` of the value `Bob`, which happens to be non-unique,
  as there is another `user` owning the same attribute in the database already;
* the second `user` has correct username, but also has non-unique email, which is forbidden by the `@unique` constraint.

As a result we have the following error:

.Error message
----
[THW04] Invalid Thing Write: Attempted to assign a key of type 'name' onto a(n) 'user' that already has one.
----

== #{counter:query}: Limiting possible values with regex
//define (constraint for the value that can be inserted)

We can limit possible values that an attribute can take by using a regular expression in the type definition.

.Schema with regex example
[,typeql]
----
define

task sub entity,
    owns status;
status sub attribute, value string, regex "^(STARTED|STOPPED|DELETED)$";
----

The `status` attribute type has a value type of string, but its value is limited by a regular expression.
That regular expression permits only the following exact variants of values: `STARTED`, `STOPPED`, or `DELETED`.

If a query tries to create an instance of the `status` type with, for example, the value `Created`,
it invokes the following error:

.Error message
----
Error> [THW11] Invalid Thing Write: Attempted to put an instance of 'status' with value 'Created' that does not satisfy the regular expression '^(STARTED|STOPPED|DELETED)$'.
----

//For more information on how to use regular expressions to limit attribute values,
//see the xref:typeql::data/advanced.adoc[] section.

== #{counter:query}: Matching data with regex
//match (constraint for the valued matched)

Use the `like` keyword with a regular expression to set constraints for an attribute value in a `match` clause.

.Query with regex example
[,typeql]
----
match
    $f isa file, has path $p;
    $p like "^docs/.*$";
----

The query above will find all files with path starting with `docs/`.

== #{counter:query}: Arithmetic expressions
_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

Arithmetic expressions let you perform basic math operations on any value in a `match` clause.

See the list of available xref:typedb::fundamentals/patterns.adoc#_arithmetic_operations[arithmetic operations].

////
Here is the list of available operations sorted in the order of execution:

include::typedb::fundamentals/patterns.adoc[tag=arithmetics]

Additionally, the following functions are available:

include::typedb::fundamentals/patterns.adoc[tag=functions]
////

////
* `()` -- parentheses
* `^` -- exponentiation (power)
* `*` -- multiplication
* `/` -- division
* `%` -- modulo. Returns the remainder of the division
* `+` -- addition
* `-` -- subtraction
////

Let's insert a few files with different sizes, that are calculated:

.Insert files with file sizes
[,typeql]
----
match
    $f isa file, has path "docs/quickstart-guide.adoc", has size-kb $s;
    ?x = ($s * 2) + 200;
    ?y = abs ((?x * 3) - 1);
insert
    $f1 isa file, has path "config.yaml", has size-kb ?x;
    $f2 isa file, has path "logs.zip", has size-kb ?y;
----

The above query inserts two files with `size-kb` values calculated based on the value of the `size-kb`
of the matched existing file.
See the resulted data visualization on the image below.

image::typedb-in-20-queries/math.png[Arithmetics, width = 50%, link=self]

[#_counterquery_rule_based_inference]
== #{counter:query}: Rule-based inference
_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

TypeDB reasoning engine can perform rule-based inference when you read data.
To use inference, we need to xref:typeql::schema/define-types.adoc[Define] rules in the schema,
open a `read` transaction with the `infer` option xref:typedb::development/infer.adoc#_how_to_use_inference[enabled],
and send a xref:typeql::data/get.adoc[Get] query.

.Schema with a rule
[,typeql]
----
define

rule every-person-is-a-dude:
    when {
        $p isa person;
    } then {
        $p has name "Dude";
    };
----

The above query adds exactly one rule:
it should add an ownership of the attribute of type `name` and value `Dude` for any person.
Effectively, all instances of `person` type or its subtypes will have name `Dude`.

[#_counterquery_rule_chaining]
== #{counter:query}: Rule chaining
_Run this query after <<_schema,query #1>> and <<_data,query #2>>._

Rules can be applied one after another in a chain.

.Schema
[,typeql]
----
define

file owns size-mb,
    owns size-gb;

size-mb sub attribute, value long;
size-gb sub attribute, value long;

rule compute-mb:
    when {
        $f isa file,
            has size-kb $kb;
        ?mb = $kb / 1024;
    } then {
        $f has size-mb ?mb;
    };

rule compute-gb:
    when {
        $f isa file,
            has size-kb $mb;
        ?gb = $mb / 1024;
    } then {
        $f has size-mb ?gb;
    };
----

The above schema adds two rules and necessary attributes.
The first rule uses arithmetic to set value for `size-mb` depending on the value of `size-kb`.
The second rule uses the same approach, but based on the results from first rule to compute `size-gb`.

== #{counter:query}: Relation transitivity
_Run this query on an empty database._

Rules can enable transitivity of relations.

Transitivity lets you expand relations when certain conditions are met.
The most general case is: given a relation from A to B,
and a relation from B to C, we can imply a relation from A to C.

Using rules for transitivity can greatly simplify your TypeQL queries.

.Schema
[,typeql]
----
define

group-membership sub relation,
    relates group,
    relates member;

user sub entity,
    owns name,
    plays group-membership:member;

user-group sub entity,
    owns name,
    plays group-membership:group,
    plays group-membership:member;

name sub attribute, value string;

rule transitive-group-membership:
   when {
      (group: $g1, member: $g2) isa group-membership;
      (group: $g2, member: $u) isa group-membership;
   } then {
      (group: $g1, member: $u) isa group-membership;
   };
----

The above schema defines `group-membership` relation with two roles: `group` and `member`.
It also defines `user` that can play a `member` role and a `user-group`, that can play both roles.
Finally, we have a rule `transitive-group-membership` that adds transitivity for the `group-membership` relation.

We can include Group A in Group B,
so that every member of Group A will become a member of Group B through the transitivity of membership, as follows:

`user` -> Group A -> Group B.

Transitivity rules work for any number of steps/nested levels.

For example, if we insert data of group-membership according to the following:

`user` -> Group A -> Group B -> Group C -> Group D -> Group E

Then the transitivity, implemented by
the `transitive-group-memmbership` rule, will make `user` into a member of all groups: from Group A to Group E.

For more information on rule inference, see the xref:typeql::schema/define-rules.adoc[] page
in xref:typeql::overview.adoc[TypeQL documentation].
