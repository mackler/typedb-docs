= TypeDB in 20 queries
//:toc: macro
//:toclevels: 5
//:toc-title: Top query examples:
:example-caption!:

This page is full of TypeQL query examples to showcase TypeDB features.
Feel free to try any of the examples yourself.

If you are not sure how to send a query to TypeDB, check our xref:typedb::quickstart-guide.adoc[].
For more information about sending queries to TypeDB, check the
xref:typedb::development/connect.adoc[] page.

To learn more about the queries, check the links in the respective section.

To showcase the capabilities of TypeDB and its query language TypeQL,
see below a short list of example queries designed to give a brief idea of what can be done and how easy it is.

//toc::[]

[#_pera]
== #{counter:query}: PERA model

TypeDB uses Polymorphic Entity-Relation-Attribute (or PERA) model for its schemas and data.

Entities, relations, and attributes are all first-class citizens in a data model allowing for
expressive modeling without normalization or reification.
There are three root types: `entity`, `relation`, and `attribute`;
and they can be subtyped to create user-defined types.

All data stored in a database must be instantiated from types, defined in a schema of a database.

Let's use the following schema definition as example.

[NOTE]
====
Use our xref:typedb::quickstart-guide.adoc[Quickstart guide]
to find out how to create a new database and send the query.
====

[#_pera_schema]
.Schema
[,typeql]
----
define

person sub entity,
    owns full-name;
user sub person,
    owns email @unique,
    owns name @key,
    plays permission:subject;
file sub entity,
    owns path @key,
    owns size-kb,
    plays permission:object;

permission sub relation,
    owns updated,
    relates subject,
    relates object;

full-name sub attribute, value string;
id sub attribute, abstract, value string;
email sub id;
path sub id;
name sub id;
size-kb sub attribute, value long;
updated sub attribute, value datetime;
----

The above TypeQL fragment is a xref:typeql::schema/define-types.adoc[Define] query that defines a few types:
four entity types, two relation types, and six attribute types.
The Define query above can be used in an empty TypeDB database, because it is self-sufficient.
But if at any time you decide to extend or modify your schema in an existing database, you can do it easily:
see the <<_counterquery_extending_the_schema>> section below.

.Visualize a schema in TypeDB Studio
====
To retrieve all types of a schema from a database it is sufficient to query for all subtypes of the root types:
`entity`, `relation`, and `attribute`.
The following query works with any TypeDB database and any schema:

.Retrieve schema types
[,typeql]
----
match
    $t sub $r;
    {$r sub entity;} or {$r sub relation;} or {$r sub attribute;};
----

The above query returns all types of a schema defined in a database.

If you send the above query with TypeDB Studio, you can get the following graph visualization.

image:typedb-in-20-queries/era-schema.png[era-schema, width=50%, link=self]
====

The above Define query

.Insert sample data
====
To insert some sample data into a database with the schema above, you can use the following insert queries:

.Insert sample data
[,typeql]
----
insert
    $u isa user,
        has name "Bob",
        has email "bob@vaticle.com";
    $f isa file,
        has path "docs/README.md";
     $p(subject:$u, object:$f) isa permission;
----

The above query inserts a single instance of `user` entity type and a single `file` entity,
each owning a single attribute, and a relation between the two entities.

Use our xref:typedb::quickstart-guide.adoc[Quickstart guide] to find out how to create a new database
and send the queries above.
====

.Retrieve some data
====
To retrieve the inserted data, use the Get query:

.Get sample data
[,typeql]
----
match
    $u isa user,
        has email $e;
    $f isa file,
        has path $path;
     $p(subject:$u, object:$f) isa permission;
----

For the query, the schema and the data above, see the result below.

image:typedb-in-20-queries/era-data.png[era-data, width=50%, link=self]
====

[#_declarative]
== #{counter:query}: Composable patterns

TypeQL statements are combined with a conjunction, which makes patterns fully-composable.
You can combine multiple patterns to extend or filter results of a query.

// tag::preload[]
[NOTE]
====
To run queries from this section, use a database with the schema and data from the <<_pera>> section.
====
// end::preload[]

Given the schema and data from previous query (<<_pera>>), let's explore the following queries:

.Query 1
[,typeql]
----
match
    $u isa user,
        has email "bob@vaticle.com";
----

The above query returns all instances of the `user` type
that own an instance of the `email` type with exact value of `bob@vaticle.com`.

.Query 2
[,typeql]
----
match
    $f isa file,
        has path "docs/README.md";
----

The above query returns all instances of the `file` type
that own an instance of the `path` type with exact value of `docs/README.md`.

Now let's combine the previous two queries:

.Query 3
[,typeql]
----
match
    $u isa user,
        has email "bob@vaticle.com";
    $f isa file,
        has path "docs/README.md";
    (subject:$u, object:$f) isa permission;
----

The above query matches all users
that have the `email` of `bob@vaticle.com` and participate in a `permission` relation with a `file`
type entity, that has the `path` attribute `docs/README.md`.

As you can see, we combined two patterns: one two find users and another one to find files,
by using a relation between them.

== #{counter:query}: Polymorphic queries

Querying for a supertype will return all results for its subtypes.

include::typedb-in-20-queries.adoc[tag=preload]

[,typeql]
----
match
    $u isa user, has id $i;
----

The above xref:typeql::data/get.adoc[Get] query will return pairs of `$u` and `$i`:

* `$u` can be an instance of either the `user` type or any of its subtypes (e.g., `employee`),
* `$i` can be an instance of any subtypes of the `id` type.
  Since the `id` type is abstract, it can't be instantiated directly, only by subtyping.

[#_counterquery_extending_the_schema]
== #{counter:query}: Extending a schema
//subtyping
//adding a role-player
//adding attributes to entities

A schema of a TypeDB database can be extended at any time without the need to rewrite existing queries.
The easiest way to extend the schema is to add a new type, add an ownership of an attribute type, add a role, or
add an ability to play a new role with a xref:typeql::schema/define-types.adoc[Define] query.

include::typedb-in-20-queries.adoc[tag=preload]

.Schema extension variants
[tabs]
====
Add a new type::
+
--
[,typeql]
----
define

blocked sub attribute, value boolean;

action sub entity,
    owns name @key;
----
--

Add an ownership::
+
--
[,typeql]
----
define

user owns blocked;
----
--

Add a role::
+
--
[,typeql]
----
define

permission relates permited-action;
----
--

Add an ability to play a role::
+
--
[,typeql]
----
define

action plays permission:permited-action;
----
--

All together::
+
--
[,typeql]
----
define

action sub entity,
    owns name @key,
    plays permission:permited-action;

user owns blocked;

permission relates permited-action;

blocked sub attribute, value boolean;
----
--
====

== #{counter:query}: Abstract types

Abstract types can't be instantiated (no data can be inserted for the abstract type), but can be subtyped.

When inheriting ownership of an abstract attribute by a concrete type,
you need to override an abstract attribute with a concrete subtype of it.

.Overriding an abstract attribute example
[tabs]
=====
Default example::
+
--
To run the following query, use a database with the schema and data from the <<_pera>> section.

.Override example
[,typeql]
----
define

user owns id;
dude sub user,
    owns dude-id as id;

dude-id sub id;
----
--
Self-sufficient example::
+
--
To run the following query, use an empty database.

.Override example
[,typeql]
----
define

person sub entity, abstract,
    owns id;

user sub person,
    owns user-id as id;

id sub attribute, abstract, value string;
user-id sub id;
----
--
=====
//#todo Add inserting data?


[#_counterquery_inserting_data_with_or_without_context]
== #{counter:query}: Inserting data with or without context

An xref:typeql::data/insert.adoc[Insert] query can be used with or without a `match` clause, as it is optional.

include::typedb-in-20-queries.adoc[tag=preload]

Let's insert some data directly:

.Insert query
[,typeql]
----
insert
    $u isa user,
        has email "john@email.com";
    $f isa file,
        has path "insert.py";
    (subject:$u, object:$f) isa permission;
----

The above query inserts a user with email `john@email.com`, a file with path `insert.py`,
and a relation of the `permission` type between the new user and the new file.
It doesn't include any pre-existing data from a database.

Now let's do a match insert by adding a new file and a relevant permission for an existing user:

.Match insert
[,typeql]
----
match
    $u isa user,
        has email "john@email.com";
insert
    $f isa file,
        has path "match-insert.py";
    (subject:$u, object:$f) isa permission;
----

The above query matches all instances of `user` type with the email `john@email.com`.
Then, for every matched result (there should be only one result),
it inserts a new file `match-insert.py` and a new permission with the matched user and the inserted file.

To limit the number of inserts to exactly one, make sure the `match` clause has only one result.
The best way to do it is by matching a xref:typeql::schema/define-types.adoc#_unique_attribute[unique attribute],
like the `email` for the `user`.
See the <<_pera_schema,schema definition>> query.

The `insert` clause can be executed multiple times, if there are multiple matched results:

.Match insert with multiple inserts
[,typeql]
----
match
    $u isa user,
        has email "john@email.com";
    $f isa file;
insert
    (subject:$u, object:$f) isa permission;
----

The above query will match the user with the email `john@email.com` and every instance of the `file` type.
And for every result, consisting of the same user and a different file,
the `insert` clause is executed by inserting a `permission` relation.

== #{counter:query}: Deleting data

Deleting data from a database requires matching the data to delete.

[NOTE]
====
For the following query we use the data from the
<<_counterquery_inserting_data_with_or_without_context>> section.
====

.Delete permissions
[,typeql]
----
match
    $u isa user,
        has email "john@email.com";
delete
    (subject:$u) isa permission;
----

The above query will delete all permission relations for the user with `john@email.com` email.

== #{counter:query}: Inheritance

xref:typeql::fundamentals.adoc#_inheritance[Inheritance] lets subtypes use roles and attributes,
defined for their supertype (direct or nested).

include::typedb-in-20-queries.adoc[tag=preload]

.Inheritance
[,typeql]
----
define

person sub entity,
    owns full-name;
user sub person,
    owns email @unique,
    owns name @key;
employee sub user,
    owns employee-id;
employee-id sub id;
----

Given the schema above, we can use `employee` with inherited attributes and roles:

.Using inherited attributes
[,typeql]
----
insert
    $e isa employee,
        has employee-id "e1234",
        has email "kate@gmail.com",
        has full-name "Kate Smith";
----

In the query above we can insert an instance of `employee` type with `employee-id` and with some of the attribute types,
defined for its supertypes (`user` and `person`).
For example, `full-name` attribute can be owned by an instance of the `employee` type through inheritance.

== #{counter:query}: Overriding inheritance

You can override an inherited ownership or a role with a new name.
//#todo Add explanation as to why it might be needed

Override uses the keyword `as` with the new type preceding the keyword, and old (inherited) type following the keyword.

The new type should be defined in the schema as a subtype of the overriden (inherited) type.

[NOTE]
====
To run the following query, use an empty database.
====

.Override example
====
.Schema
[,typeql]
----
define

person sub entity, abstract,
    owns id,
    plays participation:participant;

user sub person,
    owns user-id as id,
    plays usage:user;

participation sub relation,
    relates participant;

usage sub participation,
    relates user as participant;

id sub attribute, abstract, value string;
user-id sub id;
----

In the above example, we override the inherited `id` attribute type with the `user-id` attribute type.
We also override the `participant` role, inherited by the `usage` relation with the `user` role.
====

== #{counter:query}: Relations with a single role
//n-ary
//nested
//variadic (1 role, many role players?)

A relation type can have one or multiple roles.
If there is only one role in a relation type, then all role-players are equal in the role they play in that relation.

One of the most popular examples of such a relation is friendship.
Every role-player in a friendship plays the same role: `friend`.

Every role can be played by zero, one, or many role-players.
An instance of a relation type with a role without any role players usually represents an incomplete data state.
Like a learning-course without a teacher, or marriage with only one spouse.

include::typedb-in-20-queries.adoc[tag=preload]

.Relation with a single role
[,typeql]
----
define

friendship sub relation,
    relates friend;

person plays friendship:friend;
----

In the above query we define the `friend` role of the `friendship` relation type.
The last line defines that the `person` type can play the `friend` role in the `friendship` type relations.
Other types can't play the role, unless it is defined in the schema.

.Example of a friendship relation
====
Let's xref:typeql::data/insert.adoc[insert] some friends:

.Inserting friends
[,typeql]
----
insert
    $p1 isa person, has full-name "Chandler":
    $p2 isa person, has full-name "Joey";
    ($p1, $p2) isa friendship;
----

In the above query we are inserting two entities, each owning one attribute,
and a relation of the `friendship` type between them.
Notably, we omitted roles in a relation insertion.
That is because there is only one role, that the `person` type instances can play in that relation.

Now let's add a third friend to the same `friendship` relation.

.Inserting one more friend
[,typeql]
----
match
    $p1 isa person, has full-name "Chandler":
    $p2 isa person, has full-name "Joey";
    $f($p1, $p2) isa friendship;
insert
    $p3 isa person, has full-name "Ross";
    $f($p3) isa friendship;
----

In the above query we match existing people from the database and a `friendship` relation between them.
For every matched result of two such people and a relation between them, the query inserts a third friend.

To retrieve the inserted relation and its role-players, use the following xref:typeql::data/get.adoc[Get] query:

.Retrieve all friends
[,typeql]
----
match
    $p isa person,
        has full-name $n;
    $f($p) isa friendship;
----

TypeDB Studio can visualize the result of the Get query as it is shown below.

image::typedb-in-20-queries/friendship.png[friendship, width=50%, link=self]
====

== #{counter:query}: Relations with multiple roles

A relation can have more than one role.
Having multiple roles means that role-players can play different roles in a relation.

In an N-ary relation type, every N-1 combination of roles should make sense.
For example, in a learning course relation type that relates a student, a teacher, and a location,
the relation between students and teacher also makes sense in the context of learning course.
As well as teacher/location, or student/location combinations.
There could be many people, each playing the `student` role in the same `learning-course` relation.

.Examples
[tabs]
=====
Learning course example::
+
--
.Schema
[,typeql]
----
define

learning-course sub relation,
    owns subject-name,
    relates teacher,
    relates student,
    relates location;

subject-name sub attribute, value string;

person
    plays learning-course:teacher,
    plays learning-course:student;

room sub entity,
    owns number,
    owns address,
    plays learning-course:location;

number sub attribute, value long;
address sub attribute, value string;
----

The `person` type instances can play at least two roles in a `learning-course` relation:
the `teacher` and  the `student`.
In this example, there are, most likely, multiple students, at least one teacher and at least one location.
There could be multiple teachers or locations for the same course.
If there is no role-players for the `teacher` or the `location` roles, then it's probably an incomplete data state.

.Inserting relation with multiple roles
[,typeql]
----
insert
    $t isa person, has full-name "Isabel Roth";
    $s1 isa person, has full-name "Martin Sloan";
    $s2 isa person, has full-name "Josie Sears";
    $s3 isa person, has full-name "Solomon Wallace";
    $r isa room,
        has number 304,
        has address "Wellington Square, Oxford OX1 2JD, UK";
    (location:$r, teacher:$t, student:$s1, student: $s2, student:$s3) isa learning-course,
        has subject-name "Computer Science";
----

The above query inserts three students, one teacher, one room,
and a learning-course relation with subject name `Computer science`.

With a delicate query adjustment (by changing the `insert` keyword
to the `match` and replacing all attribute values with variables),
TypeDB Studio can visualize the result as it is shown below.

image::typedb-in-20-queries/learning-course.png[learning-course, width=50%, link=self]
--
Movies example::
+
--
[,typeql]
----
define

cast sub relation,
    owns estimated-salary-usd,
    relates actor,
    relates movie-role,
    relates studio,
    relates movie;

actor sub person,
    plays cast:actor;
person sub entity,
    owns name;

movie sub entity,
    owns name,
    owns year-released,
    plays cast:movie;

movie-role sub entity,
    owns character-name,
    plays cast:movie-role;

name sub attribute, value string;
year-released sub attribute, value long;
character-name sub attribute, value string;
estimated-salary-usd sub attribute, value long;
----

In this example, usually there is one actor playing one or multiple roles in one movie with one or multiple studios.
And the relation itself has an attribute of estimated salary in USD.
--
=====
//#todo Add permission relation example

////
== #{counter:query}: Transitive relations

.Schema
[,typeql]
----
define

group-membership sub relation,
    relates group,
    relates group-member;

user plays group-membership:group-member;

user-group sub entity,
    owns name,
    plays group-membership:group,
    plays group-membership:group-member;
----

[,typeql]
----
insert



----


////

== #{counter:query}: Globally unique attributes

Only an attribute can have a value, and the value type is set by the attributes type definition.
An instance of an attribute type has a unique value among all instances of the same type.

[IMPORTANT]
====
There can be no other instance of the same type with the same value.
====

For example, if more than one person has the same name, they will all own the same name attribute with the value.

.Example of owning the same instance
=====

// tag::empty[]
[NOTE]
====
This example is self-sufficient and designed to run in an empty database.
====
// end::empty[]

Consider the following schema:

.Schema
[,typeql]
----
define

name sub attribute, value string;

person sub entity, owns name;
company sub entity, owns name;
movie sub entity, owns name;

connection sub relation,
    owns name,
    relates connected-to;

person plays connection:connected-to;
company plays connection:connected-to;
movie plays connection:connected-to;
----

The `name` attribute type can be owned by three different entity types and one relation type.

Let's insert some data.

.Insert data
[,typeql]
----
insert

$p1 isa person, has name "Bob";
$p2 isa person, has name "Bob";
$c isa company, has name "Bob";
$m isa movie, has name "Bob";

$con($p1, $p2, $c, $m) isa connection, has name "Movie production", has name "Bob";
----

In the above query create a single instance of the `name` attribute type with the value "Bob"
and insert ownership of it to instances of other types.
Notice that we didn't specifically create the attribute "Bob" of the `name` type.
We assigned ownership over it, and the attribute was created implicitly, because it didn't exist previously.

The relation we inserted has ownership over two attributes of the same type.
One of those attributes is the same "Bob",
and the second one was also implicitly created upon the first assignment of ownership.

Using TypeDB Studio, we can visualize the resulted data as the image below.

image::typedb-in-20-queries/unique-attributes.png[unique attributes, width=50%, link=self]
=====

== #{counter:query}: Immutable attributes

Attributes have values and are immutable.
We can't change the value of an attribute.
We can replace it with another attribute of the same type but a different value.

[IMPORTANT]
====
The value of an attribute can't be changed.
====

To change a value owned by some instance of a type,
we delete an ownership of the attribute with the old value form the type
and insert ownership of the new attribute with the new value.

For example, to change a name of a person,
we xref:typeql::data/delete.adoc[Delete] an ownership of old name
and xref:typeql::data/insert.adoc[Insert] ownership of the new one.
We can delete the old name itself (the attribute), but that would influence all people with that particular name.

.Attribute ownership example
====
.Schema
[,typeql]
----
define

name sub attribute, value string;
person sub entity, owns name;
----

.Insert data
[,typeql]
----
insert
    $p isa person, has name "Ken";
----

.Update name
[,typeql]
----
match
    $p isa person, has name "Ken";
delete
    $p has name "Ken";
insert
    $p has name "Kendra";
----

The above Update query matches the person with the old name,
then, for all matched results, deletes the name "Ken" and inserts the name "Kendra".
====

== #{counter:query}: Attribute annotations
//Key
//Unique

When defining an ownership of an attribute type, we can add one of possible annotations: `@key` or `@unique`.

The `@unique` annotation makes the ownership constrained by uniqueness.
That means, that instances of the owner type can't own any instance of owned attribute more than once.

The `@key` annotation makes the owned attribute a key for the owner type.
That applies the same constraint as uniqueness and a cardinality of exactly one,
meaning that all instances of the owner type must have exactly one instance of the owned attribute.

The annotation constraints are limiting what can be inserted into a database.

.Example
=====

include::typedb-in-20-queries.adoc[tag=empty]

Consider the following schema:

.Schema
[,typeql]
----
define

user sub entity,
    owns email @unique,
    owns name @key;

name sub attribute, value string;
email sub attribute, value string;
----

In the schema xref:typeql::schema/define-types.adoc[Define]
query above we define the `name` type to be a key for the `user` type.
Now let's insert correct data with the following query.

.Insert data
[,typeql]
----
insert
    $u isa user,
        has name "Bob",
        has email "bob@vaticle.com";
----
=====

Try some invalid queries that violate annotation constraints below.

.Examples of violating annotation constraints
[tabs]
====
Unique annotation violation::
+
--
[,typeql]
----
insert
    $u isa user,
        has name "Totally not Bob",
        has email "bob@vaticle.com";
----

The above query attempts to insert another user with the same email.
Since `email` owned by `user` with the `@unique` annotation, this query invokes the following error:

.Error message
----
Error> [THW07] Invalid Thing Write: Attempted to assign a unique attribute 'bob@vaticle.com' of type 'email' that had been taken by another 'user'.
----
--
Key missing::
+
--
[,typeql]
----
insert
    $u isa user,
        has email "nameless@vaticle.com";
----

The above query attempts to insert a user without a name.
Since `named` owned by `user` with the `@key` annotation,
this query invokes the following error (upon commiting the transaction):

.Error message
----
[CNX12] TypeDB Connection: Transaction failed to commit, due to:
[THW06] Invalid Thing Write: Attempted to commit a(n) 'user' that is missing key(s) of type(s): 'name'
----
--
More than one key::
+
--
[,typeql]
----
insert
    $u isa user,
        has name "Not Bob";
        has name "Totally not Bob";
        has email "not-bob@vaticle.com";
----

The above query attempts to insert a user with more than one name.
Since `named` owned by `user` with the `@key` annotation, this query invokes the following error:

.Error message
----
[THW04] Invalid Thing Write: Attempted to assign a key of type 'name' onto a(n) 'user' that already has one.
----
--
====

== #{counter:query}: Limiting possible values with regex
//define (constraint for the value that can be inserted)

We can limit possible values that an attribute can take by using a regular expression in the type definition.

.Example
====
.Schema
[,typeql]
----
define

task sub entity,
    owns status;
status sub attribute, value string, regex "^(STARTED|STOPPED|DELETED)$";
----

The `status` attribute type has a value type of string, but its value is limited by a regular expression.
That regular expression permits only the following exact variants of values: `STARTED`, `STOPPED`, or `DELETED`.

.Correct insert
[,typeql]
----
insert
    $t isa task, has status "STARTED";
----

The above query runs as usual because the `status` value complies with all the constraints.

.Incorrect insert
[,typeql]
----
insert
    $t isa task, has status "Created";
----

The above query tries to create an instance of the `status` type with the value `Created`.
It violates the regular expression constraint on the `status` value and invokes the following error:

.Error message
----
Error> [THW11] Invalid Thing Write: Attempted to put an instance of 'status' with value 'Created' that does not satisfy the regular expression '^(STARTED|STOPPED|DELETED)$'.
----
====

//For more information on how to use regular expressions to limit attribute values,
//see the xref:typeql::data/advanced.adoc[] section.

== #{counter:query}: Matching data with regex
//match (constraint for the valued matched)

Use the `like` keyword with a regular expression to set constraints for an attribute value in a `match` clause.

include::typedb-in-20-queries.adoc[tag=preload]

.Like example
====
[,typeql]
----
match
    $f isa file, has path $p;
    $p like "^docs/.*$";
----

The query above will find all files with path starting with `docs/`.
====

The `contains` keyword lets you find a string that contains the selected substring without using regex.

.Contains example
====
[,typeql]
----
match
    $f isa file, has path $p;
    $p contains "docs/";
----

The query above will find all files with path that contains substring `docs/`.
====

== #{counter:query}: Arithmetic expressions

Arithmetic expressions let you perform basic math operations on any value in a `match` clause.

Here is the list of available operations sorted in the order of execution:

include::typedb::fundamentals/patterns.adoc[tag=arithmetics]

Additionally, the following functions are available:

include::typedb::fundamentals/patterns.adoc[tag=functions]

////
* `()` -- parentheses
* `^` -- exponentiation (power)
* `*` -- multiplication
* `/` -- division
* `%` -- modulo. Returns the remainder of the division
* `+` -- addition
* `-` -- subtraction
////

.Example
=====

include::typedb-in-20-queries.adoc[tag=empty]

.Schema
[,typeql]
----
define

file sub entity,
    owns path,
    owns size-kb;

size-kb sub attribute, value long;
path sub attribute, value string;
----

Let's insert a few files for the schema above:

.Insert data
[,typeql]
----
insert
    $f1 isa file, has path "config.yaml", has size-kb 35;
    $f2 isa file, has path "logs.zip", has size-kb 21345218;
    $f3 isa file, has path "calculator.py", has size-kb 312703;
----

Now try the following xref:typeql::data/get.adoc[Get] query with arithmetic expressions:

.Retrieve data
[,typeql]
----
match

$f isa file, has size-kb $s;
?mb = round( $s / 1024 );
?mb > 1;
----
//This query isn't working properly with Studio 2.21 - 2.24
//#todo Check with Studio 2.25+ when it will be released or with a minor release with a hotfix

The above query retrieves all files that have size-kb attribute and then divides the `size-kb` value by `1024`
and rounds the result.
The query has a constraint for the result (the value variable `?mb`) to be more than `1`.
The result will contain only files with `size-kb` over `1024`.

=====

== #{counter:query}: Rule-based inference

TypeDB reasoning engine can perform rule-based inference in `read` transactions.
To use inference, we need to match the following conditions:

1. Define rules in the schema.
2. Run a `read` transaction with the `infer` option enabled.
3. Send a Get query.

.Simple example
====
.Schema
[,typeql]
----
define

person sub entity,
    owns name;

name sub attribute, value string;

rule every-person-is-a-dude:
    when {
        $p isa person;
    } then {
        $p has name "Dude";
    };
----

The above schema contains one entity with one attribute owned and one rule.
The rule is simple: it should add an ownership of the attribute of type `name` and value `Dude` for any person.

Let's insert a person:

.Insert data
[,typeql]
----
insert
    $p isa person, has name "Bob";
----

Let's try sending a Get query without inference option enabled.

.Read data
[,typeql]
----
match
    $p isa person, has name $fn;
----

The result is a single person with a single name, that we inserted.

Now let's
xref:typedb::development/infer#_how_to_use_inference.adoc#[enable] the `infer` transaction option
to see the results of the same query with inference:

.Read data with inference
[,typeql]
----
match
    $p isa person, has name $fn;
----

The result includes not only the data we inserted, but also inferred data (person having a name `Dude`).
====

.Rule example with arithmetic
====
[,typeql]
----
define

file sub entity,
    owns path,
    owns size-kb,
    owns size-mb;

size sub attribute, abstract, value long;
size-kb sub size;
size-mb sub size;
path sub attribute, value string;

rule compute-mb:
    when {
        $f isa file,
            has size-kb $kb;
        ?mb = $kb / 1024;
    } then {
        $f has size-mb ?mb;
    };
----

The above schema contains one entity, four attributes, and one rule.
The rule uses arithmetic to set value for `size-mb` depending on the value of `size-kb`.

Let's insert a file with `size-kb`:

.Insert data
[,typeql]
----
insert
    $f isa file,
        has path "archive.zip",
        has size-kb 54321;
----

Let's try sending a Get query without inference option enabled.

.Read data
[,typeql]
----
match
    $p isa files, has $a;
----

The above query returns all files with all attributes owned.
Without the inference, it returns only the data we inserted.

Now let's
xref:typedb::development/infer#_how_to_use_inference.adoc#[enable] the `infer` transaction option
to see the results of the same query with inference:

.Read data with inference
[,typeql]
----
match
    $p isa files, has $a;
----

The result includes not only the data we inserted,
but also inferred data (`size-mb` populated with the value of `size-kb` divided by `1024`).
====

Inferred data is never persisted in a database,
but inferred on query time based on present data and rules from a schema.

[#_counterquery_rule_chaining]
== #{counter:query}: Rule chaining

Rules can be applied one after another in a chain.

.Example
====
.Schema
[,typeql]
----
define

file sub entity,
    owns path,
    owns size-kb,
    owns size-mb,
    owns size-gb;

size sub attribute, abstract, value long;
size-kb sub size;
size-mb sub size;
size-gb sub size;
path sub attribute, value string;

rule compute-mb:
    when {
        $f isa file,
            has size-kb $kb;
        ?mb = $kb / 1024;
    } then {
        $f has size-mb ?mb;
    };

rule compute-gb:
    when {
        $f isa file,
            has size-kb $mb;
        ?gb = $mb / 1024;
    } then {
        $f has size-mb ?gb;
    };
----

The above schema contains one entity, five attributes, and two rules.
It is slightly extended version of the schema from previous section <<_counterquery_rule_chaining>>.

The first rule uses arithmetic to set value for `size-mb` depending on the value of `size-kb`.
The second rule uses the same approach, but based on the results from first rule to compute `size-gb`.

Let's insert a file with `size-kb`:

.Insert data
[,typeql]
----
insert
    $f isa file,
        has path "archive.zip",
        has size-kb 54321;
----

Now let's
xref:typedb::development/infer#_how_to_use_inference.adoc#[enable] the `infer` transaction option
to see the results of the query with inference:

.Read data with inference
[,typeql]
----
match
    $p isa files, has $a;
----

The result includes not only the data we inserted,
but also data inferred by both rules (`size-mb` and `size-gb`).
====

== #{counter:query}: Rule for relation transitivity

Rules can enable transitivity of relations.

Transitivity lets you expand rules when certain conditions are met.
The most general case is: given a relation from A to B,
and a relation from B to C, we can imply a relation from A to C.

.Example
====

.Schema
[,typeql]
----
define

group-membership sub relation,
    relates group,
    relates member;

user sub entity,
    owns name,
    plays group-membership:member;

user-group sub entity,
    owns name,
    plays group-membership:group,
    plays group-membership:member;

name sub attribute, value string;

rule transitive-group-membership:
   when {
      (group: $g1, member: $g2) isa group-membership;
      (group: $g2, member: $u) isa group-membership;
   } then {
      (group: $g1, member: $u) isa group-membership;
   };
----

The above schema defines `group-membership` relation with two roles: `group` and `member`.
It also defines `user` that can play a `member` role and a `user-group`, that can play both roles.
Finally, we have a rule `transitive-group-membership` that adds transitivity for the `group-membership` relation.

We can include Group A in Group B,
so that every member of Group A will become a member of Group B through the transitivity of membership, as follows:

`user` -> Group A -> Group B.

Transitivity rules work for any number of steps/nested levels.

For example, if we insert data of group-membership according to the following:

`user` -> Group A -> Group B -> Group C -> Group D -> Group E

Then the transitivity, implemented by
the `transitive-group-memmbership` rule, will make `user` into a member of all groups: from Group A to Group E.

For more information on rule inference, see the xref:typeql::schema/define-rules.adoc[] page
in xref:typeql::overview.adoc[TypeQL documentation].
====







////
== #{counter:query}: Driver API schema modification
//based on Studio ???
//rename
//change a supertype
//etc.

//step-by-step guide for Studio


== #{counter:query}: Find all permissions for Kevin



[,typeql]
----

----




////
