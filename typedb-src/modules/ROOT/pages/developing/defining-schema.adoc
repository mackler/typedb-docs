= Defining a schema
:Summary: How to define a schema for a TypeDB database.
:page-aliases: typedb::development/schema.adoc
:keywords: typedb, typeql, schema, define, undefine, type, rule
:pageTitle: Defining a schema

Before inserting any data into a database, we need to declare its data model.
In TypeDB that is done by defining a schema.

[#_schema]
== Schema

A TypeDB schema is like a blueprint of a database.
It consists of definitions for all types and rules used in a database.
Types follow the xref:typedb::basics/data-model.adoc[PERA model] to represent a business domain of a database.
Rules are defined with a special xref:typeql::schema/define-rules.adoc#_syntax[syntax]
that lets them use data statements to xref:typedb::developing/infer.adoc[infer] new data.

All queries are written with xref:typedb::basics/query-language.adoc[TypeQL]
and validated not only for their syntax, but also for type violations.
New types can be created by subtyping existing types.
Every subtype has a single parent (or supertype).
Subtypes inherit properties of their supertypes.
A definition of a type declares its supertype, as well as its own properties and constraints.
Query patterns can use xref:typedb::basics/polymorphic-patterns.adoc[polymorphism]
to retrieve data of different types, even those not mentioned in the patterns.

A newly created database has the <<_default_schema,default schema>> that can be extended by user-defined types.

[#_default_schema]
== Default schema

A database is created with the default schema,
that contains built-in xref:typeql::schema/define-types.adoc#_abstract[abstract]
types and cannot be deleted, but can be extended.
These built-in types include the root types: `entity`, `relation`, and `attribute`,
that can be subtyped to create a full hierarchy of types for a data model.

There are no rules in the default schema.

Built-in types are not shown in schema export results, as they are internal and similar for all TypeDB databases.

[#_thing_type]
=== Thing type

Root types have a common supertype -- the `thing` type.
It is also an abstract type, but it can't be subtyped directly.
Instead, as all abstract types, the `thing` can be used in a xref:typedb::basics/polymorphic-patterns.adoc[polymorphic]
pattern as a part of a query.
See an example below.

.The thing type example
[,typeql]
----
match
$x isa thing;
get $x;
----

The `thing` is a common supertype for all types in a database, so the above query returns every `$x`
that is an instance of any root type: `entity`, `relation`, or `attribute`.

include::typedb::partial$thing-warning.adoc[]

== How to define a schema

There are multiple ways we can modify an existing schema of a TypeDB database:

* A xref:typeql::schema/define-rules.adoc[Define] query -- <<_extend_a_schema,extend>> a schema by defining new types and rules.
* An xref:typeql::schema/undefine.adoc[Undefine] query -- <<_truncate_a_schema,truncate>> a schema by removing types and rules.
* xref:drivers::overview.adoc[TypeDB drivers]
(see
xref:drivers::rust/overview.adoc[Rust],
xref:drivers::python/overview.adoc[Python],
xref:drivers::java/overview.adoc[Java], or
xref:drivers::nodejs/overview.adoc[Node.js]) --
perform schema modifications via API methods, including renaming a type, changing type's supertype, etc.
* xref:typedb::connecting/studio.adoc[TypeDB Studio] --
perform schema modifications via GUI with Type Browser and Type Editor.

This page only covers TypeQL queries as the default way of interacting with a database.
For more information on other ways to modify a schema, see the links above.
TypeQL queries can be used with any TypeDB Client, including TypeDB drivers.

[#_extend_a_schema]
== Extend a schema

Any schema can be extended by adding new types, new properties to existing types,
as well as adding new rules or replacing existing rules.

We can do that with a Define query: for xref:typeql::schema/define-types.adoc[types]
and xref:typeql::schema/define-rules.adoc[rules] in a schema.

=== Define types

To define a new type in a schema, use one of the existing types to create a subtype:

.Types hierarchy example
[,typeql]
----
define

subject sub entity;
user sub subject;
person sub user;
----

The above `Define` query uses one pre-existing type -- `entity` root type from the default schema.
So this query can be run with a new empty database.

We can extend the resulted schema by defining a new type and a new property:

.Adding new types and properties
[,typeql]
----
define

full-name sub attribute, value string;
person owns full-name;
----

The above query adds an attribute type and an ability to own it for the `person` type.
In doing so the query relies on the pre-existing type `person` and the root type `attribute`.
This query can be run only with a schema that already has a `person` type.

For more information on combining statements with a comma,
see the
xref:typedb::basics/polymorphic-patterns.adoc#_complex_statement[complex statement] section on the
xref:typedb::basics/polymorphic-patterns.adoc[] page.

We can further extend our schema by adding even more types and properties,
but this time, let's duplicate some of the existing definitions to make the query easier to read.

.Extending a schema
[,typeql]
----
define

credential sub attribute, value string;
id sub attribute, abstract, value string;
email sub id, value string;
full-name sub attribute, value string;

subject sub entity,
    abstract,
    owns credential;

person sub user,
    owns email,
    owns full-name,
    plays friendship:friend;

friendship sub relation,
    relates friend;
----

The above query contains some of the definitions that already exist in our database, for example,
`subject sub entity`.
TypeDB ignores redundant (repeated) definitions and only applies new statements to the schema.

By adding the `owns email` part to the definition of the `person` type,
we are effectively adding an ability to own attribute type `email` for the `person` type.
But the `owns full-name` statement has no effect in the above query,
as the statement `person owns full-name;` was defined before.
If we change the `full-name` attribute type to something new, like `full-name2`, in the same query,
then it will be treated as a new attribute type, co-existing with existing `full-name` type.

[IMPORTANT]
====
Define statements are idempotent.
Sending the same Define query two or more times achieves the same result as sending it only once.
Neither types nor rules can be duplicated.
====

For more information of how to define types with TypeQL Define query, see the
xref:typeql::schema/define-types.adoc[] page in the TypeQL documentation.

[#_define_rules]
=== Define rules

To define a rule use the keyword `rule`, a rule's label, followed by a `when` and a `then` clauses in a Define query:

[,typeql]
----
define

rule <rule-label>: when {
    ## condition
} then {
    ## conclusion
};
----

Rule label must be unique in a schema.
Defining a rule with an existing label rewrites the old rule with the new one.
A condition definition in a `when` clause uses a pattern similar to a xref:typeql::data/match.adoc[match clause].
A conclusion definition in a `then` clause uses a single statement inserting ownership of an attribute or a relation.
A condition and a conclusion of a rule must include valid patterns,
including the requirement of using the types from the same schema where the rule is defined.

See an example below for the schema defined earlier on this page:

.Rule example
[,typeql]
----
define

rule all-friends: when {
    $p1 isa person;
    $p2 isa person;
    not {$p1 is $p2;};
} then {
    (friend: $p1, friend: $p2) isa friendship;
};
----

For more information on rule definitions and validation, see the
xref:typeql::schema/define-rules.adoc[] page in the TypeQL documentation.

For more information on using rules to infer new data, see the xref:typedb::developing/infer.adoc[] page.

[#_truncate_a_schema]
== Truncate a schema

Any schema can be truncated by removing existing types, their properties, and existing rules.

We can do that with an xref:typeql::schema/undefine.adoc[Undefine query].

[#_undefine_types]
=== Undefine types

To remove a statement about a type from a schema, use it in an Undefine query.

.Undefine example
[,typeql]
----
undefine

full-name sub attribute;
----

The above example removes the `full-name` attribute type from a schema.
To be able to remove a type from a schema, that type must have neither a subtype defined in a schema,
nor data of that type inserted to a database.
Undefining a type also removes all references of the type in a schema in regard to ownerships and roles.
In the above example, statement `person owns full-name` also get removed from a schema.

For more information on undefining types, see the xref:typeql::schema/undefine.adoc[] page.

[#_undefine_subtype]
[IMPORTANT]
====
To be able to remove a type, it needs to have no subtypes in a schema and no data in a database.
====

[#_undefine_rules]
=== Undefine rules

To undefine a type, use the following syntax:

[,typeql]
----
undefine

rule <rule-label>;
----

Undefining a rule does not require repeating its condition or conclusion.

== Delete a schema

There is no way of deleting a schema of a database.
You can remove all user-defined types and all rules to revert a schema to the default schema state.
It is usually easier to just delete the whole database.

== Create a new schema

There is no way of creating a new schema or deleting an existing one.
You can remove all user-defined types and all rules to revert a schema to the default schema state.
It is usually easier to just delete the whole database and create a new one with the same name and the default schema.

== Rename a type

To rename a type, use the xref:typedb:ROOT:connecting/studio.adoc[TypeDB Studio] or TypeDB driver API methods.
//#todo Add tabs with code snippets and links to API ref?

== Modify a rule

You can replace a rule with a new one by <<_define_rules,defining a new rule>> with the same label as the old one.

== Learn more

After you defined a schema, you can xref:typedb::developing/write.adoc[write] some data to the database.

If you don't have your own schema ready yet, feel free to continue using the
https://github.com/vaticle/typedb-docs/blob/master/typedb-src/modules/ROOT/attachments/iam-schema.tql[IAM schema,window=_blank].
