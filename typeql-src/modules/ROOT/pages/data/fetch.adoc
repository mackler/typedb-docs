= Fetch query
:Summary: Reading data from a TypeDB database with a Fetch query.
:keywords: typeql, query, fetch, read, retrieve, json
:pageTitle: fetch query

A Fetch query retrieves values from a TypeDB database and returns them as JSON strings.

It can and should be used in a read transaction.
Hence, it can be used with rule-based xref:typedb::fundamentals/inference.adoc[inference].

== Behavior

A Fetch query triggers a search in a database, using a pattern from a `match` clause.
For every matched result, it executes the `fetch` clause of the query, that
fetches values (types, attribute values, and aggregated values) from
specified variables and executes specified subqueries.

A Fetch query returns a stream/iterator of results.
Every returned result is a valid JSON string.
The number of query results returned is equal to the number of solutions matched by a `match` clause.
If there are no matches in the preceding `match` clause,
there are no JSON strings returned by the `fetch` clause of the same query.

== Syntax

A Fetch query consists of a
<<_match_clause,match>> and a
<<_fetch_clause,fetch>> clauses,
followed by optional <<_modifiers,modifiers>>.

Fetch queries are written in TypeQL with the following syntax:

.Fetch query syntax
[,typeql]
----
match <pattern>
fetch (
    variable [as <label>] ;
  | variable [as <label>] : [<attribute-type> [as <label>], ...] ;
  | <subquery-label>      : { <fetch_query> | <get_aggregate_query> } ;
)
[<modifiers>]
----

The variable or variables mentioned in a `fetch` clause must be bound (set) in the `match` clause of the same query.

[#_match_clause]
== Match clause

A `match` clause is mandatory in a Fetch query.
You can use a declarative and composable TypeQL pattern in a `match` clause and TypeDB will find data that matches
the pattern.
After a `match` clause goes another clause (`insert`, `delete`, `fetch`, or `get`)
to specify what to do with the matched data.

For more information on a `match` clause, see the
//#todo update the link after introducing the Match clause page!
xref:typeql::queries.adoc#_match[Match clause] description on the Queries page.

For more information on patterns used in a `match` clause, see the
xref:data/basic-patterns.adoc#_patterns_overview[Pattern syntax] section.

[#_fetch_clause]
== Fetch clause

A `fetch` clause is used in a Fetch query
to specify a projection of values from matched data to an output of JSON strings.

This clause is executed exactly once for every result matched by the `match` clause of the same query.
A `fetch` clause produces a valid JSON string for every matched result.
The content of the JSON string is defined by the variables, types, and subqueries used in it.

Following the `fetch` keyword are one or multiple variables or subqueries, separated by semicolons.
Every variable or subquery mentioned in a `fetch` clause adds a top-level key
with the same label to the resulted JSON strings.

Variable can optionally be followed by a colon and a list of comma-separated attribute-types.
Every attribute type mentioned in this way adds a JSON subsection with the same label as a key.
The value of the subsection is the list of attribute type's instances owned by the matched concept from a variable.

Fetch always needs a value to project into JSON.
Hence, entities and relations can be used as variables in a `fetch` clause only by specifying valid attribute types
that they can own, according to a schema.

.Fetch query example
[,typeql]
----
match
$p isa person, has full-name $n;
fetch
$n;
$p: attribute;
try-subquery: {match $p has email $e; $e contains "kevin"; fetch $e;};
----

Every instance in the JSON output has its type, root type, and value (if applicable).

.Fetch query result example
[,js]
----
{
    "n": { "value": "Kevin Morrison", "value_type": "string", "type": { "label": "full-name", "root": "attribute" } },
    "p": {
        "attribute": [
            { "value": "Kevin Morrison", "value_type": "string", "type": { "label": "full-name", "root": "attribute" } },
            { "value": "kevin.morrison@vaticle.com", "value_type": "string", "type": { "label": "email", "root": "attribute" } }
        ],
        "type": { "label": "person", "root": "entity" }
    },
    "try-subquery": [ { "e": { "value": "kevin.morrison@vaticle.com", "value_type": "string", "type": { "label": "email", "root": "attribute" } } } ]
}
----

[#_subqueries]
=== Subqueries

As it was shown in the example above, a Fetch query can include a subquery with a label.
Label determines a key that will be used to introduce subquery's results into the JSON output.

The label is followed by a colon, and then, TypeQL string for a subquery, enveloped into curly brackets.
A subquery can be of two types: a Fetch query or a Get query with
xref:typeql::data/get.adoc#_aggregation[aggregation] (to return a value).

A subquery shares variables with its parent query.
The number of nested subqueries is not limited,
but many nested levels can easily break technical limitations of gRPC messaging.

For an example of nested subqueries, see the <<_grouping_results>> section below.

[#_relabeling]
=== Relabeling

A `fetch` clause support relabeling of variables and attribute types.
You can assign alias label which will be used for JSON output.

.Example of relabeling
[,typeql]
----
match
$p isa person;
fetch
$p as person: full-name as name;
sort $n;
----

.Example of result with relabeling
[,js]
----
{
    "person": {
        "name": [ { "value": "Kevin Morrison", "value_type": "string", "type": { "label": "full-name", "root": "attribute" } } ],
        "type": { "label": "person", "root": "entity" }
    }
}
----

[#_number_of_answers]
=== Number of answers

A Fetch query can return fewer results, than it was matched by its `match` clause.
That is due to natural deduplication of attributes.
See an example below.

.Example of a fetch clause reducing the number of results
[,typeql]
----
match
$p isa person, has name $n;
fetch
$n;
----

In the above example `match` clause matches all `person` type instances that own a `name` attribute.
The `fetch` clause then returns values of those `name` attributes.

What happens if two persons have the same name?
In TypeDB database that stored, as two entities own the same instance of the `name` attribute type.
The `match` clause finds all pairs of a person entity and its owned attribute.
But `fetch` clause returns only the attributes, and since both persons owning the very same attribute,
it will only be returned once, reducing the total number of results.

For more examples of filtering matched results,
see the xref:typeql::data/get.adoc#_answers_example_2[Get query] page.

[#_modifiers]
== Modifiers

In a Fetch query, modifiers can change the number and order of results.

The following modifiers can be used at the end of a Fetch query:
<<_sort_the_answers,sort>>,
<<_offset_the_answers,offset>>, and
<<_limit_the_results,limit>>.

They can be used to add pagination for the query results.

[#_sort_the_answers]
=== Sort the answers

.Sort modifier syntax
[,typeql]
----
sort <variable> [asc|desc] [,<variable> [asc|desc]];
----

Use the `sort` keyword followed by a variable to sort the answers using a variable mentioned in the first argument. A
second argument is optional and determines the sorting order: `asc` (ascending, used by default) or `desc` (descending).

.Sort example
[,typeql]
----
match $p isa person, has full-name $n;
fetch $n;
sort $n asc;
----

This query returns sorted values of all `full-name` attributes owned by `person` entities.

To sort by multiple variables, add additional variables with a comma separator.

[#_offset_the_answers]
=== Offset the answers

.Offset modifier syntax
[,typeql]
----
offset <value>;
----

Use the `offset` keyword followed by the number to offset the answers.
This is commonly used with the `limit` keyword to return a desired range of answers.
Don't forget to <<_sort_the_answers,sort>> the results to ensure predictable and deterministic results.

.Offset example
[,typeql]
----
match $p isa person, has full-name $n;
fetch $n;
sort $n asc;
offset 1;
----

This sorts the `full-name` attributes of all `person` entities in ascending order, skips the first six, and returns up
to the next ten.

[#_limit_the_results]
=== Limit the results

.Limit modifier syntax
[,typeql]
----
limit <value>;
----

Use the `limit` keyword followed by a positive integer to limit the number of results (answers) returned.

.Limit example
[,typeql]
----
match $p isa person, has full-name $n;
fetch $n;
sort $n asc;
offset 1;
limit 1;
----

This query returns only one single (and random) instance of type `person`. Consider using `limit` with
<<_sort_the_answers,sort>> to receive less random and more predictable results.

== Examples

//mention IAM schema and data
The following examples use the
https://github.com/vaticle/typedb-docs/blob/master/typedb-src/modules/ROOT/attachments/iam-schema.tql[IAM schema,window=_blank] and
https://github.com/vaticle/typedb-docs/blob/master/typedb-src/modules/ROOT/attachments/iam-data.tql[IAM sample data,window=_blank].

=== Fetch an attribute

To fetch an attribute, use the following query:

.Example of fetching an attribute
[,typeql]
----
match
$f isa file, has path $p;
fetch
$p;
----

The above query matches files with their `path` attributes and then fetches the `path` attribute.

.Result example
[,js]
----
{ "p": { "value": "README.md", "value_type": "string", "type": { "label": "path", "root": "attribute" } } }
----

=== Fetch all attributes owned

To fetch all attributes, owned by any type, we can fetch a variable with a colon followed by the `attribute` root type:

.Example of fetching all attributes of every file
[,typeql]
----
match
$f isa file;
fetch
$f: attribute;
----

The above query matches all files (even those that do not have any attributes)
and then fetches all attributes for every file.

.Result example
[,js]
----
{
    "f": {
        "attribute": [
            { "value": 55, "value_type": "long", "type": { "label": "size-kb", "root": "attribute" } },
            { "value": "iopvu.java", "value_type": "string", "type": { "label": "path", "root": "attribute" } }
        ],
        "type": { "label": "file", "root": "entity" }
    }
}
----

=== Using Get queries as subqueries

You can use xref:typeql::data/get.adoc[Get] queries as subqueries as long as you use
xref:typeql::data/get.adoc#_aggregation[aggregation] to get a value.

.Example of using a Get subquery
[,typeql]
----
match
$p isa person, has full-name $n;
fetch
$n;
$p: attribute;
try-subquery: {match $p has email $e; $e contains "kevin"; get $e; count;};
----

In the above query, we use Get query with count aggregation to get the number of emails with "kevin" substring owned
for every user.
Hence, the value in "try-subquery" key has no type.

.Result example
[,js]
----
{
    "n": { "value": "Kevin Morrison", "value_type": "string", "type": { "label": "full-name", "root": "attribute" } },
    "p": {
        "attribute": [
            { "value": "Kevin Morrison", "value_type": "string", "type": { "label": "full-name", "root": "attribute" } },
            { "value": "kevin.morrison@vaticle.com", "value_type": "string", "type": { "label": "email", "root": "attribute" } }
        ],
        "type": { "label": "person", "root": "entity" }
    },
    "try-subquery": { "value": 1, "value_type": "long" }
}
----

=== Using inference

We can use Fetch query to infer new facts.
For example, we can use the `add-view-permission` rule from the
https://github.com/vaticle/typedb-docs/blob/master/typedb-src/modules/ROOT/attachments/iam-schema.tql[IAM schema,window=_blank]
to infer `view_file` action access permissions.

.Example of using inference
[,typeql]
----
match
$o isa object, has path $fp;
$pa($o, $va) isa access;
$va isa action, has name 'view_file';
fetch $fp;
----

Using the
https://github.com/vaticle/typedb-docs/blob/master/typedb-src/modules/ROOT/attachments/iam-data.tql[IAM sample data,window=_blank]
the above query shows any results only if inference is
xref:typedb::development/infer.adoc#_how_to_use_inference[enabled].

.Result example with inference enabled
[,js]
----
{ "fp": { "value": "README.md", "value_type": "string", "type": { "label": "path", "root": "attribute" } } }
----

Try the same query with disabled inference to see no matched results.

[#_complex_example]
=== Complex example

Let's try a bigger example with a little bit of everything:

.Complex example
[,typeql]
----
match
$u isa user;
$o isa object;
$va isa action, has name "view_file";
$pa($o, $va) isa access;
$p($u, $pa) isa permission;
fetch
$u as user: full-name, email;
$o as object: attribute as all-attributes;
$va as action: name as action-name;
convert-size: {
    match
    $o has size-kb $sk;
    ?sm = round( $sk / 1024 );
    fetch
    ?sm as size-mb; };
----

The above query matches all users and all objects, that those users can access with `view_file` action.
Then it fetches `full-name` and `email` attributes for users,
all attributes for objects and `name` attributes for action.
Finally, for every matched result it runs a subquery to convert `size-kb` to `size-mb`.

The result is a stream/iterator of JSON strings. See example of such JSON string below.

.Result example
[,js]
----
{
    "action": {
        "action-name": [ { "value": "view_file", "value_type": "string", "type": { "label": "name", "root": "attribute" } } ],
        "type": { "label": "operation", "root": "entity" }
    },
    "convert-size": [ { "size-mb": { "value": 1, "value_type": "long" } } ],
    "object": {
        "all-attributes": [
            { "value": 758, "value_type": "long", "type": { "label": "size-kb", "root": "attribute" } },
            { "value": "budget_2022-05-01.xlsx", "value_type": "string", "type": { "label": "path", "root": "attribute" } }
        ],
        "type": { "label": "file", "root": "entity" }
    },
    "user": {
        "email": [ { "value": "pearle.goodman@vaticle.com", "value_type": "string", "type": { "label": "email", "root": "attribute" } } ],
        "full-name": [ { "value": "Pearle Goodman", "value_type": "string", "type": { "label": "full-name", "root": "attribute" } } ],
        "type": { "label": "person", "root": "entity" }
    }
}
----

Note how we do not match any attributes, except for `name` for action in the `match` clause.
If we do match instances of a type with `has <attribute-type>` statement that excludes all instances that do not own
any of such attribute type.

For example: `$u isa user, has full-name $fn;` would exclude all users that do not have any
`full-name`.
At the same time, mathing `$u usa user;` and then fetching `$u: full-name;` will return even those users
that do not own any `full-name` attributes.
The corresponding value would contain an empty list of values in this case.

[#_grouping_results]
==== Grouping results

One might want to group query results to reduce the size of a response or simplify further processing.
In a fetch query that can be achieved by utilizing <<_subqueries,subqueries>>.
For example, see below how to group the results from <<_complex_example,previous example>> by user.

.Grouping by user example
[,typeql]
----
match
$u isa user;
fetch
$u as user: attribute as all-attributes;
permited-files:{
    match
    $o isa object;
    $va isa action, has name "view_file";
    $pa($o, $va) isa access;
    $p($u, $pa) isa permission;
    fetch
    $o as object: attribute as all-attributes;
    convert-size: {
        match
        $o has size-kb $sk;
        ?sm = round( $sk / 1024 );
        fetch
        ?sm as size-mb; }; };
----

The above query matches all users at first.
Then it fetches all attributes for every user and runs a subquery for a subsection labeled as `permitted-files`.

This subquery matches all objects that participate in an `access` relation with action named `view_file` that
play a role in a `permission` relation with the user matched by the parent query.
Then it fetches all attributes for such objects and runs another subquery.

The second subquery matches all objects that have `size-kb` attribute and converts its value into some new value
with arithmetic.
Then it fetches the converted value as `size-mb`.

The resulting JSON strings have a predictable structure of keys, that was set by the `fetch` clauses, using
<<_relabeling,relabeling>>:

* user
** all-attributes
* permitted-files
** object
*** all-attributes
** convert-size

See an example of the partial output below.

.Result example
[,js]
----
{
    "permited-files": [
        {
            "convert-size": [ { "size-mb": { "value": 1, "value_type": "long" } } ],
            "object": {
                "all-attributes": [
                    { "value": 758, "value_type": "long", "type": { "label": "size-kb", "root": "attribute" } },
                    { "value": "budget_2022-05-01.xlsx", "value_type": "string", "type": { "label": "path", "root": "attribute" } }
                ],
                "type": { "label": "file", "root": "entity" }
            }
        },
...
    ],
    "user": {
        "all-attributes": [
            { "value": "Kevin Morrison", "value_type": "string", "type": { "label": "full-name", "root": "attribute" } },
            { "value": "kevin.morrison@vaticle.com", "value_type": "string", "type": { "label": "email", "root": "attribute" } }
        ],
        "type": { "label": "person", "root": "entity" }
    }
}
----

Note that the order of key/value pairs in JSON is not guaranteed.
